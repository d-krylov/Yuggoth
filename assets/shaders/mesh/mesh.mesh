#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_mesh_shader : require
#extension GL_EXT_shader_explicit_arithmetic_types : require

#include "../common/mesh.glsl"

// PUSH CONSTANTS
layout (push_constant) uniform PushConstants {
	mat4 projection;
	mat4 view;
  mat4 model;
} pc;

// INPUTS
layout (set = 0, binding = 0) readonly buffer Vertices { Vertex vertices[]; };
layout (set = 0, binding = 1) readonly buffer Indices { uint indices[]; };
layout (set = 0, binding = 2) readonly buffer Meshlets { Meshlet meshlets[]; };

layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

// OUT
layout (triangles, max_vertices = 64, max_primitives = 42) out;

layout (location = 0) out vec3 out_position[];
layout (location = 1) out vec3 out_normal[];
layout (location = 2) out vec3 out_color[];
layout (location = 3) out vec2 out_uv[];


void main() {
  
  uint meshlet_index = gl_WorkGroupID.x;

  Meshlet meshlet = meshlets[meshlet_index];

  uint triangle_count = meshlet.index_count / 3;

  SetMeshOutputsEXT(meshlet.index_count, triangle_count);

  for (uint k = 0; k < meshlet.index_count; ++k) {
    uint index = indices[meshlet.index_offset + k];
    Vertex vertex = vertices[index];
    
    vec3 position = vec3(vertex.px, vertex.py, vertex.pz);
    vec3 normal = vec3(vertex.nx, vertex.ny, vertex.nz);
    vec2 uv = vec2(vertex.uvx, vertex.uvy);

    out_position[k] = vec3(pc.model * vec4(position, 1.0));
	  out_normal[k] = mat3(transpose(inverse(pc.model))) * normal;
    out_color[k] = vec3(float(meshlet_index % 2), float(meshlet_index % 3) / 2.0, float(meshlet_index % 5) / 4.0);
	  out_uv[k] = uv;

    gl_MeshVerticesEXT[k].gl_Position = pc.projection * pc.view * pc.model * vec4(position, 1.0);
  }

  for (uint t = 0; t < triangle_count; ++t) {
    gl_PrimitiveTriangleIndicesEXT[t] = uvec3(t * 3 + 0, t * 3 + 1, t * 3 + 2);
  }

}