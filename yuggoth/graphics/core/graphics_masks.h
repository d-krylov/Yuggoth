
#ifndef YUGGOTH_GRAPHICS_MASKS_H
#define YUGGOTH_GRAPHICS_MASKS_H

// includes
#include "yuggoth/core/tools/include/mask.h"

namespace Yuggoth {

enum class Flags {
};

// content
using FramebufferCreateMask = Mask<FramebufferCreateMaskBits>;
using QueryPoolCreateMask = Mask<QueryPoolCreateMaskBits>;
using RenderPassCreateMask = Mask<RenderPassCreateMaskBits>;
using SamplerCreateMask = Mask<SamplerCreateMaskBits>;
using PipelineLayoutCreateMask = Mask<PipelineLayoutCreateMaskBits>;
using PipelineCacheCreateMask = Mask<PipelineCacheCreateMaskBits>;
using PipelineDepthStencilStateCreateMask = Mask<Flags>;
using PipelineDynamicStateCreateMask = Mask<Flags>;
using PipelineColorBlendStateCreateMask = Mask<Flags>;
using PipelineMultisampleStateCreateMask = Mask<Flags>;
using PipelineRasterizationStateCreateMask = Mask<Flags>;
using PipelineViewportStateCreateMask = Mask<Flags>;
using PipelineTessellationStateCreateMask = Mask<Flags>;
using PipelineInputAssemblyStateCreateMask = Mask<Flags>;
using PipelineVertexInputStateCreateMask = Mask<Flags>;
using PipelineShaderStageCreateMask = Mask<PipelineShaderStageCreateMaskBits>;
using DescriptorSetLayoutCreateMask = Mask<DescriptorSetLayoutCreateMaskBits>;
using BufferViewCreateMask = Mask<Flags>;
using InstanceCreateMask = Mask<InstanceCreateMaskBits>;
using DeviceCreateMask = Mask<Flags>;
using DeviceQueueCreateMask = Mask<DeviceQueueCreateMaskBits>;
using QueueMask = Mask<QueueMaskBits>;
using MemoryPropertyMask = Mask<MemoryPropertyMaskBits>;
using MemoryHeapMask = Mask<MemoryHeapMaskBits>;
using AccessMask = Mask<AccessMaskBits>;
using BufferUsageMask = Mask<BufferUsageMaskBits>;
using BufferCreateMask = Mask<BufferCreateMaskBits>;
using ShaderStageMask = Mask<ShaderStageMaskBits>;
using ImageUsageMask = Mask<ImageUsageMaskBits>;
using ImageCreateMask = Mask<ImageCreateMaskBits>;
using ImageViewCreateMask = Mask<ImageViewCreateMaskBits>;
using PipelineCreateMask = Mask<PipelineCreateMaskBits>;
using ColorComponentMask = Mask<ColorComponentMaskBits>;
using FenceCreateMask = Mask<FenceCreateMaskBits>;
using SemaphoreCreateMask = Mask<Flags>;
using FormatFeatureMask = Mask<FormatFeatureMaskBits>;
using QueryControlMask = Mask<QueryControlMaskBits>;
using QueryResultMask = Mask<QueryResultMaskBits>;
using ShaderModuleCreateMask = Mask<Flags>;
using EventCreateMask = Mask<EventCreateMaskBits>;
using CommandPoolCreateMask = Mask<CommandPoolCreateMaskBits>;
using CommandPoolResetMask = Mask<CommandPoolResetMaskBits>;
using CommandBufferResetMask = Mask<CommandBufferResetMaskBits>;
using CommandBufferUsageMask = Mask<CommandBufferUsageMaskBits>;
using QueryPipelineStatisticMask = Mask<QueryPipelineStatisticMaskBits>;
using MemoryMapMask = Mask<MemoryMapMaskBits>;
using MemoryUnmapMask = Mask<MemoryUnmapMaskBits>;
using ImageAspectMask = Mask<ImageAspectMaskBits>;
using SparseMemoryBindMask = Mask<SparseMemoryBindMaskBits>;
using SparseImageFormatMask = Mask<SparseImageFormatMaskBits>;
using SubpassDescriptionMask = Mask<SubpassDescriptionMaskBits>;
using PipelineStageMask = Mask<PipelineStageMaskBits>;
using SampleCountMask = Mask<SampleCountMaskBits>;
using AttachmentDescriptionMask = Mask<AttachmentDescriptionMaskBits>;
using StencilFaceMask = Mask<StencilFaceMaskBits>;
using CullModeMask = Mask<CullModeMaskBits>;
using DescriptorPoolCreateMask = Mask<DescriptorPoolCreateMaskBits>;
using DescriptorPoolResetMask = Mask<Flags>;
using DependencyMask = Mask<DependencyMaskBits>;
using SubgroupFeatureMask = Mask<SubgroupFeatureMaskBits>;
using IndirectCommandsLayoutUsageMaskNV = Mask<IndirectCommandsLayoutUsageMaskBitsNV>;
using IndirectStateMaskNV = Mask<IndirectStateMaskBitsNV>;
using GeometryMaskKHR = Mask<GeometryMaskBitsKHR>;
using GeometryInstanceMaskKHR = Mask<GeometryInstanceMaskBitsKHR>;
using ClusterAccelerationStructureGeometryMaskNV = Mask<ClusterAccelerationStructureGeometryMaskBitsNV>;
using ClusterAccelerationStructureClusterMaskNV = Mask<ClusterAccelerationStructureClusterMaskBitsNV>;
using ClusterAccelerationStructureAddressResolutionMaskNV = Mask<ClusterAccelerationStructureAddressResolutionMaskBitsNV>;
using BuildAccelerationStructureMaskKHR = Mask<BuildAccelerationStructureMaskBitsKHR>;
using PrivateDataSlotCreateMask = Mask<Flags>;
using AccelerationStructureCreateMaskKHR = Mask<AccelerationStructureCreateMaskBitsKHR>;
using DescriptorUpdateTemplateCreateMask = Mask<Flags>;
using PipelineCreationFeedbackMask = Mask<PipelineCreationFeedbackMaskBits>;
using PerformanceCounterDescriptionMaskKHR = Mask<PerformanceCounterDescriptionMaskBitsKHR>;
using AcquireProfilingLockMaskKHR = Mask<AcquireProfilingLockMaskBitsKHR>;
using SemaphoreWaitMask = Mask<SemaphoreWaitMaskBits>;
using PipelineCompilerControlMaskAMD = Mask<PipelineCompilerControlMaskBitsAMD>;
using ShaderCorePropertiesMaskAMD = Mask<ShaderCorePropertiesMaskBitsAMD>;
using DeviceDiagnosticsConfigMaskNV = Mask<DeviceDiagnosticsConfigMaskBitsNV>;
using AccessMask2 = Mask<AccessMaskBits2>;
using PipelineStageMask2 = Mask<PipelineStageMaskBits2>;
using AccelerationStructureMotionInfoMaskNV = Mask<Flags>;
using AccelerationStructureMotionInstanceMaskNV = Mask<Flags>;
using FormatFeatureMask2 = Mask<FormatFeatureMaskBits2>;
using RenderingMask = Mask<RenderingMaskBits>;
using MemoryDecompressionMethodMaskNV = Mask<MemoryDecompressionMethodMaskBitsNV>;
using BuildMicromapMaskEXT = Mask<BuildMicromapMaskBitsEXT>;
using MicromapCreateMaskEXT = Mask<MicromapCreateMaskBitsEXT>;
using IndirectCommandsLayoutUsageMaskEXT = Mask<IndirectCommandsLayoutUsageMaskBitsEXT>;
using IndirectCommandsInputModeMaskEXT = Mask<IndirectCommandsInputModeMaskBitsEXT>;
using DirectDriverLoadingMaskLUNARG = Mask<Flags>;
using PipelineCreateMask2 = Mask<PipelineCreateMaskBits2>;
using BufferUsageMask2 = Mask<BufferUsageMaskBits2>;
using AddressCopyMaskKHR = Mask<AddressCopyMaskBitsKHR>;
using TensorCreateMaskARM = Mask<TensorCreateMaskBitsARM>;
using TensorUsageMaskARM = Mask<TensorUsageMaskBitsARM>;
using TensorViewCreateMaskARM = Mask<TensorViewCreateMaskBitsARM>;
using DataGraphPipelineSessionCreateMaskARM = Mask<DataGraphPipelineSessionCreateMaskBitsARM>;
using DataGraphPipelineDispatchMaskARM = Mask<DataGraphPipelineDispatchMaskBitsARM>;
using VideoEncodeRgbModelConversionMaskVALVE = Mask<VideoEncodeRgbModelConversionMaskBitsVALVE>;
using VideoEncodeRgbRangeCompressionMaskVALVE = Mask<VideoEncodeRgbRangeCompressionMaskBitsVALVE>;
using VideoEncodeRgbChromaOffsetMaskVALVE = Mask<VideoEncodeRgbChromaOffsetMaskBitsVALVE>;
using CompositeAlphaMaskKHR = Mask<CompositeAlphaMaskBitsKHR>;
using DisplayPlaneAlphaMaskKHR = Mask<DisplayPlaneAlphaMaskBitsKHR>;
using SurfaceTransformMaskKHR = Mask<SurfaceTransformMaskBitsKHR>;
using SwapchainCreateMaskKHR = Mask<SwapchainCreateMaskBitsKHR>;
using DisplayModeCreateMaskKHR = Mask<Flags>;
using DisplaySurfaceCreateMaskKHR = Mask<Flags>;
using AndroidSurfaceCreateMaskKHR = Mask<Flags>;
using ViSurfaceCreateMaskNN = Mask<Flags>;
using WaylandSurfaceCreateMaskKHR = Mask<Flags>;
using Win32SurfaceCreateMaskKHR = Mask<Flags>;
using XlibSurfaceCreateMaskKHR = Mask<Flags>;
using XcbSurfaceCreateMaskKHR = Mask<Flags>;
using DirectFBSurfaceCreateMaskEXT = Mask<Flags>;
using IOSSurfaceCreateMaskMVK = Mask<Flags>;
using MacOSSurfaceCreateMaskMVK = Mask<Flags>;
using MetalSurfaceCreateMaskEXT = Mask<Flags>;
using ImagePipeSurfaceCreateMaskFUCHSIA = Mask<Flags>;
using StreamDescriptorSurfaceCreateMaskGGP = Mask<Flags>;
using HeadlessSurfaceCreateMaskEXT = Mask<Flags>;
using ScreenSurfaceCreateMaskQNX = Mask<Flags>;
using PeerMemoryFeatureMask = Mask<PeerMemoryFeatureMaskBits>;
using MemoryAllocateMask = Mask<MemoryAllocateMaskBits>;
using DeviceGroupPresentModeMaskKHR = Mask<DeviceGroupPresentModeMaskBitsKHR>;
using DebugReportMaskEXT = Mask<DebugReportMaskBitsEXT>;
using CommandPoolTrimMask = Mask<Flags>;
using ExternalMemoryHandleTypeMaskNV = Mask<ExternalMemoryHandleTypeMaskBitsNV>;
using ClusterAccelerationStructureIndexFormatMaskNV = Mask<ClusterAccelerationStructureIndexFormatMaskBitsNV>;
using ExternalMemoryFeatureMaskNV = Mask<ExternalMemoryFeatureMaskBitsNV>;
using ExternalMemoryHandleTypeMask = Mask<ExternalMemoryHandleTypeMaskBits>;
using ExternalMemoryFeatureMask = Mask<ExternalMemoryFeatureMaskBits>;
using ExternalSemaphoreHandleTypeMask = Mask<ExternalSemaphoreHandleTypeMaskBits>;
using ExternalSemaphoreFeatureMask = Mask<ExternalSemaphoreFeatureMaskBits>;
using SemaphoreImportMask = Mask<SemaphoreImportMaskBits>;
using ExternalFenceHandleTypeMask = Mask<ExternalFenceHandleTypeMaskBits>;
using ExternalFenceFeatureMask = Mask<ExternalFenceFeatureMaskBits>;
using FenceImportMask = Mask<FenceImportMaskBits>;
using SurfaceCounterMaskEXT = Mask<SurfaceCounterMaskBitsEXT>;
using PipelineViewportSwizzleStateCreateMaskNV = Mask<Flags>;
using PipelineDiscardRectangleStateCreateMaskEXT = Mask<Flags>;
using PipelineCoverageToColorStateCreateMaskNV = Mask<Flags>;
using PipelineCoverageModulationStateCreateMaskNV = Mask<Flags>;
using PipelineCoverageReductionStateCreateMaskNV = Mask<Flags>;
using ValidationCacheCreateMaskEXT = Mask<Flags>;
using DebugUtilsMessageSeverityMaskEXT = Mask<DebugUtilsMessageSeverityMaskBitsEXT>;
using DebugUtilsMessageTypeMaskEXT = Mask<DebugUtilsMessageTypeMaskBitsEXT>;
using DebugUtilsMessengerCreateMaskEXT = Mask<Flags>;
using DebugUtilsMessengerCallbackDataMaskEXT = Mask<Flags>;
using DeviceMemoryReportMaskEXT = Mask<Flags>;
using PipelineRasterizationConservativeStateCreateMaskEXT = Mask<Flags>;
using DescriptorBindingMask = Mask<DescriptorBindingMaskBits>;
using ConditionalRenderingMaskEXT = Mask<ConditionalRenderingMaskBitsEXT>;
using ResolveModeMask = Mask<ResolveModeMaskBits>;
using PipelineRasterizationStateStreamCreateMaskEXT = Mask<Flags>;
using PipelineRasterizationDepthClipStateCreateMaskEXT = Mask<Flags>;
using ToolPurposeMask = Mask<ToolPurposeMaskBits>;
using SubmitMask = Mask<SubmitMaskBits>;
using ImageFormatConstraintsMaskFUCHSIA = Mask<Flags>;
using HostImageCopyMask = Mask<HostImageCopyMaskBits>;
using PartitionedAccelerationStructureInstanceMaskNV = Mask<PartitionedAccelerationStructureInstanceMaskBitsNV>;
using GraphicsPipelineLibraryMaskEXT = Mask<GraphicsPipelineLibraryMaskBitsEXT>;
using ImageCompressionMaskEXT = Mask<ImageCompressionMaskBitsEXT>;
using ImageCompressionFixedRateMaskEXT = Mask<ImageCompressionFixedRateMaskBitsEXT>;
using DeviceAddressBindingMaskEXT = Mask<DeviceAddressBindingMaskBitsEXT>;
using OpticalFlowGridSizeMaskNV = Mask<OpticalFlowGridSizeMaskBitsNV>;
using OpticalFlowUsageMaskNV = Mask<OpticalFlowUsageMaskBitsNV>;
using OpticalFlowSessionCreateMaskNV = Mask<OpticalFlowSessionCreateMaskBitsNV>;
using OpticalFlowExecuteMaskNV = Mask<OpticalFlowExecuteMaskBitsNV>;
using FrameBoundaryMaskEXT = Mask<FrameBoundaryMaskBitsEXT>;
using PresentScalingMaskKHR = Mask<PresentScalingMaskBitsKHR>;
using PresentGravityMaskKHR = Mask<PresentGravityMaskBitsKHR>;
using ShaderCreateMaskEXT = Mask<ShaderCreateMaskBitsEXT>;
using TileShadingRenderPassMaskQCOM = Mask<TileShadingRenderPassMaskBitsQCOM>;
using PhysicalDeviceSchedulingControlsMaskARM = Mask<PhysicalDeviceSchedulingControlsMaskBitsARM>;
using SurfaceCreateMaskOHOS = Mask<Flags>;
using VideoCodecOperationMaskKHR = Mask<VideoCodecOperationMaskBitsKHR>;
using VideoCapabilityMaskKHR = Mask<VideoCapabilityMaskBitsKHR>;
using VideoSessionCreateMaskKHR = Mask<VideoSessionCreateMaskBitsKHR>;
using VideoSessionParametersCreateMaskKHR = Mask<VideoSessionParametersCreateMaskBitsKHR>;
using VideoBeginCodingMaskKHR = Mask<Flags>;
using VideoEndCodingMaskKHR = Mask<Flags>;
using VideoCodingControlMaskKHR = Mask<VideoCodingControlMaskBitsKHR>;
using VideoDecodeUsageMaskKHR = Mask<VideoDecodeUsageMaskBitsKHR>;
using VideoDecodeCapabilityMaskKHR = Mask<VideoDecodeCapabilityMaskBitsKHR>;
using VideoDecodeMaskKHR = Mask<Flags>;
using VideoDecodeH264PictureLayoutMaskKHR = Mask<VideoDecodeH264PictureLayoutMaskBitsKHR>;
using VideoEncodeMaskKHR = Mask<VideoEncodeMaskBitsKHR>;
using VideoEncodeUsageMaskKHR = Mask<VideoEncodeUsageMaskBitsKHR>;
using VideoEncodeContentMaskKHR = Mask<VideoEncodeContentMaskBitsKHR>;
using VideoEncodeCapabilityMaskKHR = Mask<VideoEncodeCapabilityMaskBitsKHR>;
using VideoEncodeFeedbackMaskKHR = Mask<VideoEncodeFeedbackMaskBitsKHR>;
using VideoEncodeRateControlMaskKHR = Mask<Flags>;
using VideoEncodeRateControlModeMaskKHR = Mask<VideoEncodeRateControlModeMaskBitsKHR>;
using VideoEncodeIntraRefreshModeMaskKHR = Mask<VideoEncodeIntraRefreshModeMaskBitsKHR>;
using VideoChromaSubsamplingMaskKHR = Mask<VideoChromaSubsamplingMaskBitsKHR>;
using VideoComponentBitDepthMaskKHR = Mask<VideoComponentBitDepthMaskBitsKHR>;
using VideoEncodeH264CapabilityMaskKHR = Mask<VideoEncodeH264CapabilityMaskBitsKHR>;
using VideoEncodeH264StdMaskKHR = Mask<VideoEncodeH264StdMaskBitsKHR>;
using VideoEncodeH264RateControlMaskKHR = Mask<VideoEncodeH264RateControlMaskBitsKHR>;
using VideoEncodeH265CapabilityMaskKHR = Mask<VideoEncodeH265CapabilityMaskBitsKHR>;
using VideoEncodeH265StdMaskKHR = Mask<VideoEncodeH265StdMaskBitsKHR>;
using VideoEncodeH265RateControlMaskKHR = Mask<VideoEncodeH265RateControlMaskBitsKHR>;
using VideoEncodeH265CtbSizeMaskKHR = Mask<VideoEncodeH265CtbSizeMaskBitsKHR>;
using VideoEncodeH265TransformBlockSizeMaskKHR = Mask<VideoEncodeH265TransformBlockSizeMaskBitsKHR>;
using VideoEncodeAV1CapabilityMaskKHR = Mask<VideoEncodeAV1CapabilityMaskBitsKHR>;
using VideoEncodeAV1StdMaskKHR = Mask<VideoEncodeAV1StdMaskBitsKHR>;
using VideoEncodeAV1RateControlMaskKHR = Mask<VideoEncodeAV1RateControlMaskBitsKHR>;
using VideoEncodeAV1SuperblockSizeMaskKHR = Mask<VideoEncodeAV1SuperblockSizeMaskBitsKHR>;
using AccessMask3KHR = Mask<AccessMaskBits3KHR>;

} // end namespace Yuggoth

#endif // YUGGOTH_GRAPHICS_MASKS_H
